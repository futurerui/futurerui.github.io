[{"title":"ArrayList与LinkedList","url":"/2018/08/12/ArrayList与LinkedList/","content":"ArrayList与LinkedList都是可变容量容器，\b均实现了List接口，但是ArrayList与LinkedList实现原理却有很大区别，实现方式决定了其使用场景\n\n## ArrayList源码分析\nArrayList有三个构造函数，一个无参构造，一个带有Collection参数，一个带有int型参数。ArrayList内部是基于数组实现的。默认的容量为10。对于一个容器来说，最频繁的操作莫过于添加，和删除了。首先看看添加操作。add方法有几个重载函数，首先看最基本的只有一个\b泛型类型参数的add方法。\n``` Java\npublic boolean add(E e) {\n    modCount++;\n    add(e, elementData, size);\n    return true;\n}\n\nprivate void add(E e, Object[] elementData, int s) {\n    if (s == elementData.length)\n        elementData = grow();\n    elementData[s] = e;\n    size = s + 1;\n}\n\nprivate Object[] grow() {\n    return grow(size + 1);\n}\n\nprivate Object[] grow(int minCapacity) {\n    return elementData = Arrays.copyOf(elementData,\n            newCapacity(minCapacity));\n}\n\n```\n调用`add(E e)`执行流程：add(E e)->add(E e, Object[] elementData, int s) （如果数组数据装满了）->grow()->grow(int minCapacity);可以看到如果数据没有装满则其实就是简单的在内部数组中添加元素，并增加size大小。但是数组一旦确定大小是不能改变的，而ArrayList要动态改变大小，\b关键就在grow方法中，ArrayList通过grow方法“改变数组容量”。实际是将原来的数据复制到一个新的容量大的数组中去，那么新数组容量大小如何确定呢？就看newCapacity方法：\n``` Java\nprivate int newCapacity(int minCapacity) {\n    // overflow-conscious code\n    int oldCapacity = elementData.length;\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    if (newCapacity - minCapacity <= 0) {\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)\n            return Math.max(DEFAULT_CAPACITY, minCapacity);\n        if (minCapacity < 0) // overflow\n            throw new OutOfMemoryError();\n        return minCapacity;\n    }\n    return (newCapacity - MAX_ARRAY_SIZE <= 0)\n        ? newCapacity\n        : hugeCapacity(minCapacity);\n}\n```\n新的容量为oldCapacity+oldCapacity/2倍。如果newCapacity-minCapacity<=0（minCapacity即为size+1，因为此时size与elementData.length相等，因此minCapacity为oldCapacity+1），此时elementData为默认的空数组的时候(如果使用无参构造函数就会出现这种情况)，此时返回容量为默认容量DEFAULT_CAPACITY与minCapacity之间的大者，否则返回minCapacity。如果\bnewCapacity-minCapacity<=0不满足则返回newCapacity，此时会处理一下如果容量超过最大数组大小时的情况。回到grow方法中：\n``` Java\nprivate Object[] grow(int minCapacity) {\n    return elementData = Arrays.copyOf(elementData,\n            newCapacity(minCapacity));\n}\n```\n使用的是Arrays.copyOf将原数组复制到新的数组中。跟踪进去最后可以看到是调用的：\n``` Java\npublic static <T,U> T[] copyOf(U[] original, int newLength, Class<? extends T[]> newType) {\n    @SuppressWarnings(\"unchecked\")\n    T[] copy = ((Object)newType == (Object)Object[].class)\n        ? (T[]) new Object[newLength]\n        : (T[]) Array.newInstance(newType.getComponentType(), newLength);\n    System.arraycopy(original, 0, copy, 0,\n                        Math.min(original.length, newLength));\n    return copy;\n}\n```\n在copyOf方法中首先创建了一个泛型数组，然后调用System.arraycopy方法将原数组数据复制到泛型数组中。其他的add方法以及addAll方法都是同样的思路，先判断数组容量是否够，如果不够则需要调用grow方法扩容，扩容实际就是创建一个指定容量的新数组，然后将原数组数据复制到新数组中。","tags":["Collections"]},{"title":"Algorithms 4th 学习笔记","url":"/2018/08/12/Algorithms-4th-学习笔记/","tags":["DSA"]},{"title":"Java集合学习及源码分析","url":"/2018/08/12/Java集合学习/","tags":["Collections"]},{"title":"Java运行时数据区域","url":"/2018/08/12/Java运行时数据区域/","tags":["JVM"]},{"title":"Java虚拟机学习","url":"/2018/08/12/Java虚拟机学习/","content":"不管是在写学习客户端还是Java后端，越来越觉得学习Java虚拟机的必要性，以下内容是我在学习《深入理解Java虚拟机》的学习笔记，作为对JVM一个入门的了解。\n* [运行时数据区域](https://futurerui.github.io/2018/08/12/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/)\n* [JVM垃圾回收机制]()\n* [类文件结构]()\n* [Java类加载机制]()\n* [Java内存模型]()","tags":["JVM"]},{"title":"Java并发编程学习","url":"/2018/08/12/Java并发编程/","tags":["并发"]},{"title":"Retrofit学习及源码分析","url":"/2018/08/11/Retrofit学习及源码分析/","content":"最近参加的很多面试都有问到Retrofit以及RxJava，奈何以前项目使用得不多，因此很遗憾错过了一些比较想去的公司，痛定思痛，因此回家后好好研究了一番。但是实际上做开发，要不断地学习给自己充电，否则就会掉队，因此学习不仅仅是为了应付面试，也不是说项目使用了才去学习，这是不断充实自己的一个过程。\n\n## Retrofit 简介\nRetrofit在[官网](http://square.github.io/retrofit/)有一句简单的介绍：A type-safe HTTP client for Android and Java。翻译过来就是用于Java和Android的类型安全的http客户端。\n\n## Retrofit 使用\n在grdle文件中添加依赖  \n\n``` gradle \n    implementation 'com.squareup.retrofit2:retrofit:2.4.0' \n```\n查看引进的依赖可以看到添加Retrofit依赖后自动依赖了Okhttp。\n### 定义接口\n``` Java\npublic interface GitHubService {\n    @GET(\"users/{user}/repos\")\n    Call<List<Repo>> listRepos(@Path(\"user\") String user);\n}\n```\n通过注解定义描述Http请求，Retrofit内置了五个注解GET，POST，PUT，DELETE，HEAD，如果使用HTTP注解的话可以替换以上任意一个注解。Retrofit将网络请求地址分成两部分，一个是baseURL，剩下的在接口方法中通过注解进行设置。接口中的方法返回一个Call实例。   \n请求URL可以通过替换块以及方法的参数进行动态的替换，如上述示例中通过使用{}可以实现在方法`listRepos`中动态替换，方法参数需要添加竹节`@Path(\"user\")`.  \n通过`@Query`注解可以实现动态替换URL中的参数，如下所示：\n\n``` Java \n@GET(\"users/list?sort=desc\")//写在注解中\n\n@GET(\"group/{id}/users\")\nCall<List<User>> groupList(@Path(\"id\") int groupId, @Query(\"sort\") String sort);//通过参数动态添加\n\n```\n如果有多个参数可以通过map实现，例如：\n  \n``` Java\n@GET(\"group/{id}/users\")\nCall<List<User>> groupList(@Path(\"id\") int groupId, @QueryMap Map<String, String> options);\n```\n### 调用接口\n接口定义好之后通过Retrofit设置baseURL并将请求发送出去：  \n\n``` Java \nRetrofit retrofit = new Retrofit.Builder()\n                        .addConverterFactory(GsonConverterFactory.create())\n                        .baseUrl(\"https://api.github.com/\").build();\nGitHubService service = retrofit.create(GitHubService.class);\nservice.listRepos(\"futurerui\").enqueue(new Callback<List<Repo>>() {\n    @Override\n    public void onResponse(Call<List<Repo>> call, Response<List<Repo>> response) {\n        Log.e(\"future\",\"\");\n    }\n\n    @Override\n    public void onFailure(Call<List<Repo>> call, Throwable t) {\n        Log.e(\"future\",\"\");\n    }\n});\n```\n类`Repo`是服务器返回数据的类,类中只定义了其中一部分数据：\n``` Java\npublic class Repo {\n    private String id;\n    private String name;\n    private String full_name;\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getFull_name() {\n        return full_name;\n    }\n\n    public void setFull_name(String full_name) {\n        this.full_name = full_name;\n    }\n}\n```\n通过调用create方法返回`GitHubService`实例，调用接口方法`listRepos`返回Call对象，\b调用enqueue方法将请求发送出去。  \n\b以上的示例是以GET方式请求，对于POST请求则需要使用@POST注解\n### 注解说明\n#### RequestBody\n通过`@Body`注解可以将对象设置为请求体\n``` Java\n@POST(\"users/new\")\nCall<User> createUser(@Body User user);\n```\nUser会通过Converter进行转换，如果没有设置Converter则只能使用RequestBody。\n\n#### Form Encoded以及Multipart\n当使用`@FormUrlEncoded`注解的时候会发送表单编码的数据,使用此注解表示MineType为`application/x-www-form-urlencoded`。即：\n```\nContent-Type:application/x-www-form-urlencoded\n```\n此时键值对通过`@Field`注解进行标注\n``` Java\n@FormUrlEncoded\n@POST(\"user/edit\")\nCall<User> updateUser(@Field(\"first_name\") String first, @Field(\"last_name\") String last);\n```\n`@Part` 和`PartMap`与注解`Multipart`结合使用，适用于文件上传。`Query`以及`QueryMap`用于URL上，而`Part`与`PartMap`用于请求体上。MultiPart表示请求体是一个支持文件上传的表单：\n```\nContent-Type:multipart/form-data\n```\n\n#### 请求头\n设置请求头的方式：\n* 通过@Headers注解在接口方法添加静态请求头\n* 通过@Header注解在接口方法参数中动态添加请求头\n如下所示：\n``` Java\n@Headers({\n    \"Accept: application/vnd.github.v3.full+json\",\n    \"User-Agent: Retrofit-Sample-App\"\n})\n@GET(\"users/{username}\")\nCall<User> getUser(@Path(\"username\") String username);\n```\n动态方式：\n``` Java\n@GET(\"user\")\nCall<User> getUser(@Header(\"Authorization\") String authorization)\n```\n类似于query参数，对于复杂的请求头可以使用Map方式进行动态添加，如下所示：\n``` Java \n@GET(\"user\")\nCall<User> getUser(@HeaderMap Map<String, String> headers)\n```\n如果每个请求中都需要添加相同的Header，这时可以通过OkHttp的拦截器实现。  \n\n## Retrofit源码分析\n简单的介绍了Retrofit的使用，那么Retrofit内部是如何实现的呢？Retrofit整个内部源码很少，但是构思却如此精妙，下面一起看看内部是如何实现的。  \nRetrofit实例是通过builder模式创建，然后通过baseUrl方法设置url基础部分。baseUrl与在接口方法中设置的路径的关系：\n* 如果在接口方法中设置的路径以`/`开头，那么表示此路径是绝对路径，此时会把baseUrl中\b包含的其他路径参数给覆盖掉：\n``` \nbaseUrl = \"http://example.com/api/\"\nendPoint = \"/foo/bar/\"\nresult = \"http://example.com/foo/bar/\"\n```\n* 如果EndPoint中包含host或者包含\b协议部分，则会替换掉baseUrl中的host，如果没有包含协议部分则使用baseUrl中的协议， 如果包含协议则会覆盖baseUrl的协议。\n```\nBase URL: http://example.com/\nEndpoint: https://github.com/square/retrofit/\nResult: https://github.com/square/retrofit/\n\nBase URL: http://example.com\nEndpoint: //github.com/square/retrofit/\nResult: http://github.com/square/retrofit/ \n```\n调用build()方法完成Retrofit实例的创建\n``` Java\npublic Retrofit build() {\n      if (baseUrl == null) {\n        throw new IllegalStateException(\"Base URL required.\");\n      }\n\n      okhttp3.Call.Factory callFactory = this.callFactory;\n      if (callFactory == null) {\n        callFactory = new OkHttpClient();\n      }\n\n      Executor callbackExecutor = this.callbackExecutor;\n      if (callbackExecutor == null) {\n        callbackExecutor = platform.defaultCallbackExecutor();\n      }\n\n      // Make a defensive copy of the adapters and add the default Call adapter.\n      List<CallAdapter.Factory> callAdapterFactories = new ArrayList<>(this.callAdapterFactories);\n      callAdapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));\n\n      // Make a defensive copy of the converters.\n      List<Converter.Factory> converterFactories =\n          new ArrayList<>(1 + this.converterFactories.size());\n\n      // Add the built-in converter factory first. This prevents overriding its behavior but also\n      // ensures correct behavior when using converters that consume all types.\n      converterFactories.add(new BuiltInConverters());\n      converterFactories.addAll(this.converterFactories);\n\n      return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),\n          unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);\n}\n```\n在build方法中完成了`callFactory`的实例化，`call\bFactory`默认是采用`OkHttpClient`进行实例化的。接下来是实例化`callbackExecutor`，这个\b默认是通过platform的`defaultCallbackExecutor`方法实例化。platform又是个什么东东。找到platform初始化的地方可以看到platform是通过`Platform.get();`初始化的。\n``` Java\nprivate static Platform findPlatform() {\n    try {\n      Class.forName(\"android.os.Build\");\n      if (Build.VERSION.SDK_INT != 0) {\n        return new Android();\n      }\n    } catch (ClassNotFoundException ignored) {\n    }\n    try {\n      Class.forName(\"java.util.Optional\");\n      return new Java8();\n    } catch (ClassNotFoundException ignored) {\n    }\n    return new Platform();\n}\n```\nplatform是通过反射进行确定运行在哪个平台然后进行相应的初始化，我是在Android上面使用，因此是Android类的实例。进入Android\b类中：\n``` Java\nstatic class Android extends Platform {\n    @Override public Executor defaultCallbackExecutor() {\n      return new MainThreadExecutor();\n    }\n\n    @Override CallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) {\n      if (callbackExecutor == null) throw new AssertionError();\n      return new ExecutorCallAdapterFactory(callbackExecutor);\n    }\n\n    static class MainThreadExecutor implements Executor {\n      private final Handler handler = new Handler(Looper.getMainLooper());\n\n      @Override public void execute(Runnable r) {\n        handler.post(r);\n      }\n    }\n}\n```\ncallbackExecutor是MainThreadExecutor实例。MainThreadExecutor中有一个使用主线程Looper的Handler实例。调用execute方法的时候是通过handler将runnable post出去的。  \n\n接下来就是callAdapterFactories实例，callAdapterFactories是一个List通过Retrofit的构造函数传递给Retrofit的成员变量callAdapterFactories。callAdapterFactories\b默认通过paltform的defaultCallAdapterFactory方法添加元素。\n``` Java\nCallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) {\n    if (callbackExecutor != null) {\n      return new ExecutorCallAdapterFactory(callbackExecutor);\n    }\n    return DefaultCallAdapterFactory.INSTANCE;\n}\n```\n因为callbackExecutor不为null，因此返回ExecutorCallAdapterFactory的实例。获取到Retrofit实例以后调用create方法获取定义的接口GitHubService的\b实例。create方法可以说是Retrofit最核心的部分。\n``` Java\npublic <T> T create(final Class<T> service) {\n    Utils.validateServiceInterface(service);\n    if (validateEagerly) {\n      eagerlyValidateMethods(service);\n    }\n    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },\n        new InvocationHandler() {\n          private final Platform platform = Platform.get();\n\n          @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)\n              throws Throwable {\n            // If the method is a method from Object then defer to normal invocation.\n            if (method.getDeclaringClass() == Object.class) {\n              return method.invoke(this, args);\n            }\n            if (platform.isDefaultMethod(method)) {\n              return platform.invokeDefaultMethod(method, service, proxy, args);\n            }\n            ServiceMethod<Object, Object> serviceMethod =\n                (ServiceMethod<Object, Object>) loadServiceMethod(method);\n            OkHttpCall<Object> okHttpCall = new OkHttpCall<>(serviceMethod, args);\n            return serviceMethod.adapt(okHttpCall);\n          }\n        });\n}\n```\n进入create方法可以看到return部分的代码实际是一个动态代理，因此create返回的GitHubService实例实际是一个代理类的实例，在调用其listRepos\b方法的时候实际\b会去执行create中的invoke方法。因此所有操作都是在invoke方法中完成的。其中最关键的两部分代码就是\n``` Java \nServiceMethod<Object, Object> serviceMethod =\n(ServiceMethod<Object, Object>) loadServiceMethod(method);\nOkHttpCall<Object> okHttpCall = new OkHttpCall<>(serviceMethod, args);\n```\nmethod实际就是自定义接口GitHubService中的listRepos方法。\b下面看看loadServiceMethod方法做了哪些工作。在loadServiceMethod中首先查看缓存中是否已经有对应的ServiceMethod，如果没有\b则创建，并缓存起来。主要就是看创建ServiceMethod所做的工作,ServiceMethod也是通过Builder模式创建,进入build()方法中进行查看：\n``` Java\npublic ServiceMethod build() {\n      callAdapter = createCallAdapter();\n      responseType = callAdapter.responseType();\n      if (responseType == Response.class || responseType == okhttp3.Response.class) {\n        throw methodError(\"'\"\n            + Utils.getRawType(responseType).getName()\n            + \"' is not a valid response body type. Did you mean ResponseBody?\");\n      }\n      responseConverter = createResponseConverter();\n\n      for (Annotation annotation : methodAnnotations) {\n        parseMethodAnnotation(annotation);\n      }\n\n      if (httpMethod == null) {\n        throw methodError(\"HTTP method annotation is required (e.g., @GET, @POST, etc.).\");\n      }\n\n      if (!hasBody) {\n        if (isMultipart) {\n          throw methodError(\n              \"Multipart can only be specified on HTTP methods with request body (e.g., @POST).\");\n        }\n        if (isFormEncoded) {\n          throw methodError(\"FormUrlEncoded can only be specified on HTTP methods with \"\n              + \"request body (e.g., @POST).\");\n        }\n      }\n\n      int parameterCount = parameterAnnotationsArray.length;\n      parameterHandlers = new ParameterHandler<?>[parameterCount];\n      for (int p = 0; p < parameterCount; p++) {\n        Type parameterType = parameterTypes[p];\n        if (Utils.hasUnresolvableType(parameterType)) {\n          throw parameterError(p, \"Parameter type must not include a type variable or wildcard: %s\",\n              parameterType);\n        }\n\n        Annotation[] parameterAnnotations = parameterAnnotationsArray[p];\n        if (parameterAnnotations == null) {\n          throw parameterError(p, \"No Retrofit annotation found.\");\n        }\n\n        parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);\n      }\n\n      if (relativeUrl == null && !gotUrl) {\n        throw methodError(\"Missing either @%s URL or @Url parameter.\", httpMethod);\n      }\n      if (!isFormEncoded && !isMultipart && !hasBody && gotBody) {\n        throw methodError(\"Non-body HTTP method cannot contain @Body.\");\n      }\n      if (isFormEncoded && !gotField) {\n        throw methodError(\"Form-encoded method must contain at least one @Field.\");\n      }\n      if (isMultipart && !gotPart) {\n        throw methodError(\"Multipart method must contain at least one @Part.\");\n      }\n\n      return new ServiceMethod<>(this);\n}\n```\n\n首先调用的是createCallAdapter方法：\n``` Java\nprivate CallAdapter<T, R> createCallAdapter() {\n      Type returnType = method.getGenericReturnType();\n      if (Utils.hasUnresolvableType(returnType)) {\n        throw methodError(\n            \"Method return type must not include a type variable or wildcard: %s\", returnType);\n      }\n      if (returnType == void.class) {\n        throw methodError(\"Service methods cannot return void.\");\n      }\n      Annotation[] annotations = method.getAnnotations();\n      try {\n        //noinspection unchecked\n        return (CallAdapter<T, R>) retrofit.callAdapter(returnType, annotations);\n      } catch (RuntimeException e) { // Wide exception range because factories are user code.\n        throw methodError(e, \"Unable to create call adapter for %s\", returnType);\n      }\n}\n```\ncreateCallAdapter方法中首先获取接口方法返回类型，比如说之前定义的GitHubService接口中listRepos方法的返回值类型`Call<List<Repo>>`,泛型返回值不能有通配符或者类型参数符号例如T。最后调用Retrofit中callAdapter方法，跟踪\b进去实际到最后是调用的ExecutorCallAdapterFactory中的get方法，返回一个匿名内部类CallAdapter。\b返回\b到loadServiceMethod方法中responseType即为List<Repo>。接下来就是创建responseConverter，responseConverter作用就是将响应转换为我们需要的类型。\b调用createResponseConverter方法创建，调用流程为：ServiceMethod.createResponseConverter()->Retrofit.responseBodyConverter()->Retrofit.nextResponseBodyConverter();最后在nextResponseBodyConverter方法中通过converterFactories进行获取，而converterFactories\b是一个List，存放的元素就是Converter.Factory，在之前的示例中我使用的是GsonConverterFactory.create()，这个是Gson的转换器，通过addConverterFactory方法添加。  \n\n回到create方法，\b在invoke方法中最后调用serviceMethod.adapt();进入adapt方法发现实际调用的是callAdapter的adapt方法。callAdapter前面分析过就是ExecutorCallAdapterFactory中get方法返回的\b匿名内部类CallAdapter对象。调用其adapt方法最后返回的对象是ExecutorCallbackCall，调用其enqueue方法实际调用的是Call对象的enqueue方法，即OkHttpCall对象的enqueue方法。在enqueue方法中调用的\bcall.enqueue()方法。call对象通过ServiceMethod.toCall()方法创建，toCall方法内部通过callFactory.newCall()创建，之前分析callFactory实际就是OkHttpClient，后面的处理由OKkHttpClient完成。这时整个Retrofit从创建请求到发送整个流程分析完了，可见最后请求发送是通过OkHttpClient实现的，也就是说实际发送网络请求的是OkHttp。Retrofit只是完成了创建请求以及通过Converter处理响应。大致执行流程如下图所示：\n![avatar](/img/Retrofit.png)\n","tags":["Android"]},{"title":"RxJava 学习及源码分析","url":"/2018/08/11/RxJava-学习及源码分析/","tags":["Android"]},{"title":"动态代理","url":"/2018/07/25/Dynamic-Proxy/","content":"# 动态代理\n","tags":["Java"]},{"title":"Hello World","url":"/2018/07/24/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]