[{"title":"Retrofit学习及源码分析","url":"/2018/08/11/Retrofit学习及源码分析/","content":"最近参加的很多面试都有问到Retrofit以及RxJava，奈何以前项目使用得不多，因此很遗憾错过了一些比较想去的公司，痛定思痛，因此回家后好好研究了一番。但是实际上做开发，要不断地学习给自己充电，否则就会掉队，因此学习不仅仅是为了应付面试，也不是说项目使用了才去学习，这是不断充实自己的一个过程。\n\n## Retrofit 简介\nRetrofit在[官网](http://square.github.io/retrofit/)有一句简单的介绍：A type-safe HTTP client for Android and Java。翻译过来就是用于Java和Android的类型安全的http客户端。\n\n## Retrofit 使用\n在grdle文件中添加依赖  \n\n``` gradle \n    implementation 'com.squareup.retrofit2:retrofit:2.4.0' \n```\n查看引进的依赖可以看到添加Retrofit依赖后自动依赖了Okhttp。\n### 定义接口\n``` Java\npublic interface GitHubService {\n    @GET(\"users/{user}/repos\")\n    Call<List<Repo>> listRepos(@Path(\"user\") String user);\n}\n```\n通过注解定义描述Http请求，Retrofit内置了五个注解GET，POST，PUT，DELETE，HEAD，如果使用HTTP注解的话可以替换以上任意一个注解。Retrofit将网络请求地址分成两部分，一个是baseURL，剩下的在接口方法中通过注解进行设置。接口中的方法返回一个Call实例。   \n请求URL可以通过替换块以及方法的参数进行动态的替换，如上述示例中通过使用{}可以实现在方法`listRepos`中动态替换，方法参数需要添加竹节`@Path(\"user\")`.  \n通过`@Query`注解可以实现动态替换URL中的参数，如下所示：\n\n``` Java \n@GET(\"users/list?sort=desc\")//写在注解中\n\n@GET(\"group/{id}/users\")\nCall<List<User>> groupList(@Path(\"id\") int groupId, @Query(\"sort\") String sort);//通过参数动态添加\n\n```\n如果有多个参数可以通过map实现，例如：\n  \n``` Java\n@GET(\"group/{id}/users\")\nCall<List<User>> groupList(@Path(\"id\") int groupId, @QueryMap Map<String, String> options);\n```\n### 调用接口\n接口定义好之后通过Retrofit设置baseURL并将请求发送出去：  \n\n``` Java \nRetrofit retrofit = new Retrofit.Builder()\n                        .addConverterFactory(GsonConverterFactory.create())\n                        .baseUrl(\"https://api.github.com/\").build();\nGitHubService service = retrofit.create(GitHubService.class);\nservice.listRepos(\"futurerui\").enqueue(new Callback<List<Repo>>() {\n    @Override\n    public void onResponse(Call<List<Repo>> call, Response<List<Repo>> response) {\n        Log.e(\"future\",\"\");\n    }\n\n    @Override\n    public void onFailure(Call<List<Repo>> call, Throwable t) {\n        Log.e(\"future\",\"\");\n    }\n});\n```\n类`Repo`是服务器返回数据的类,类中只定义了其中一部分数据：\n``` Java\npublic class Repo {\n    private String id;\n    private String name;\n    private String full_name;\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getFull_name() {\n        return full_name;\n    }\n\n    public void setFull_name(String full_name) {\n        this.full_name = full_name;\n    }\n}\n```\n通过调用create方法返回`GitHubService`实例，调用接口方法`listRepos`返回Call对象，\b调用enqueue方法将请求发送出去。  \n\b以上的示例是以GET方式请求，对于POST请求则需要使用@POST注解\n### 注解说明\n#### RequestBody\n通过`@Body`注解可以将对象设置为请求体\n``` Java\n@POST(\"users/new\")\nCall<User> createUser(@Body User user);\n```\nUser会通过Converter进行转换，如果没有设置Converter则只能使用RequestBody。\n\n#### Form Encoded以及Multipart\n当使用`@FormUrlEncoded`注解的时候会发送表单编码的数据,使用此注解表示MineType为`application/x-www-form-urlencoded`。即：\n```\nContent-Type:application/x-www-form-urlencoded\n```\n此时键值对通过`@Field`注解进行标注\n``` Java\n@FormUrlEncoded\n@POST(\"user/edit\")\nCall<User> updateUser(@Field(\"first_name\") String first, @Field(\"last_name\") String last);\n```\n`@Part` 和`PartMap`与注解`Multipart`结合使用，适用于文件上传。`Query`以及`QueryMap`用于URL上，而`Part`与`PartMap`用于请求体上。MultiPart表示请求体是一个支持文件上传的表单：\n```\nContent-Type:multipart/form-data\n```\n\n#### 请求头\n设置请求头的方式：\n* 通过@Headers注解在接口方法添加静态请求头\n* 通过@Header注解在接口方法参数中动态添加请求头\n如下所示：\n``` Java\n@Headers({\n    \"Accept: application/vnd.github.v3.full+json\",\n    \"User-Agent: Retrofit-Sample-App\"\n})\n@GET(\"users/{username}\")\nCall<User> getUser(@Path(\"username\") String username);\n```\n动态方式：\n``` Java\n@GET(\"user\")\nCall<User> getUser(@Header(\"Authorization\") String authorization)\n```\n类似于query参数，对于复杂的请求头可以使用Map方式进行动态添加，如下所示：\n``` Java \n@GET(\"user\")\nCall<User> getUser(@HeaderMap Map<String, String> headers)\n```\n如果每个请求中都需要添加相同的Header，这时可以通过OkHttp的拦截器实现。  \n\n## Retrofit源码分析\n简单的介绍了Retrofit的使用，那么Retrofit内部是如何实现的呢？Retrofit整个内部源码很少，但是构思却如此精妙，下面一起看看内部是如何实现的。  \nRetrofit实例是通过builder模式创建，然后通过baseUrl方法设置url基础部分。baseUrl与在接口方法中设置的路径的关系：\n* 如果在接口方法中设置的路径以`/`开头，那么表示此路径是绝对路径，此时会把baseUrl中\b包含的其他路径参数给覆盖掉：\n``` \nbaseUrl = \"http://example.com/api/\"\nendPoint = \"/foo/bar/\"\nresult = \"http://example.com/foo/bar/\"\n```\n* 如果EndPoint中包含host或者包含\b协议部分，则会替换掉baseUrl中的host，如果没有包含协议部分则使用baseUrl中的协议， 如果包含协议则会覆盖baseUrl的协议。\n```\nBase URL: http://example.com/\nEndpoint: https://github.com/square/retrofit/\nResult: https://github.com/square/retrofit/\n\nBase URL: http://example.com\nEndpoint: //github.com/square/retrofit/\nResult: http://github.com/square/retrofit/ \n```\n调用build()方法完成Retrofit实例的创建\n``` Java\npublic Retrofit build() {\n      if (baseUrl == null) {\n        throw new IllegalStateException(\"Base URL required.\");\n      }\n\n      okhttp3.Call.Factory callFactory = this.callFactory;\n      if (callFactory == null) {\n        callFactory = new OkHttpClient();\n      }\n\n      Executor callbackExecutor = this.callbackExecutor;\n      if (callbackExecutor == null) {\n        callbackExecutor = platform.defaultCallbackExecutor();\n      }\n\n      // Make a defensive copy of the adapters and add the default Call adapter.\n      List<CallAdapter.Factory> callAdapterFactories = new ArrayList<>(this.callAdapterFactories);\n      callAdapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));\n\n      // Make a defensive copy of the converters.\n      List<Converter.Factory> converterFactories =\n          new ArrayList<>(1 + this.converterFactories.size());\n\n      // Add the built-in converter factory first. This prevents overriding its behavior but also\n      // ensures correct behavior when using converters that consume all types.\n      converterFactories.add(new BuiltInConverters());\n      converterFactories.addAll(this.converterFactories);\n\n      return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),\n          unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);\n}\n```\n在build方法中完成了`callFactory`的实例化，`call\bFactory`默认是采用`OkHttpClient`进行实例化的。接下来是实例化`callbackExecutor`，这个\b默认是通过platform的`defaultCallbackExecutor`方法实例化。platform又是个什么东东。找到platform初始化的地方可以看到platform是通过`Platform.get();`初始化的。\n``` Java\nprivate static Platform findPlatform() {\n    try {\n      Class.forName(\"android.os.Build\");\n      if (Build.VERSION.SDK_INT != 0) {\n        return new Android();\n      }\n    } catch (ClassNotFoundException ignored) {\n    }\n    try {\n      Class.forName(\"java.util.Optional\");\n      return new Java8();\n    } catch (ClassNotFoundException ignored) {\n    }\n    return new Platform();\n}\n```\nplatform是通过反射进行确定运行在哪个平台然后进行相应的初始化，我是在Android上面使用，因此是Android类的实例。进入Android\b类中：\n``` Java\nstatic class Android extends Platform {\n    @Override public Executor defaultCallbackExecutor() {\n      return new MainThreadExecutor();\n    }\n\n    @Override CallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) {\n      if (callbackExecutor == null) throw new AssertionError();\n      return new ExecutorCallAdapterFactory(callbackExecutor);\n    }\n\n    static class MainThreadExecutor implements Executor {\n      private final Handler handler = new Handler(Looper.getMainLooper());\n\n      @Override public void execute(Runnable r) {\n        handler.post(r);\n      }\n    }\n}\n```\ncallbackExecutor是MainThreadExecutor实例。MainThreadExecutor中有一个使用主线程Looper的Handler实例。调用execute方法的时候是通过handler将runnable post出去的。  \n\n接下来就是callAdapterFactories实例，callAdapterFactories是一个List通过Retrofit的构造函数传递给Retrofit的成员变量callAdapterFactories。callAdapterFactories\b默认通过paltform的defaultCallAdapterFactory方法添加元素。\n``` Java\nCallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) {\n    if (callbackExecutor != null) {\n      return new ExecutorCallAdapterFactory(callbackExecutor);\n    }\n    return DefaultCallAdapterFactory.INSTANCE;\n}\n```\n因为callbackExecutor不为null，因此返回ExecutorCallAdapterFactory的实例。获取到Retrofit实例以后调用create方法获取定义的接口GitHubService的\b实例。create方法可以说是Retrofit最核心的部分。\n``` Java\npublic <T> T create(final Class<T> service) {\n    Utils.validateServiceInterface(service);\n    if (validateEagerly) {\n      eagerlyValidateMethods(service);\n    }\n    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },\n        new InvocationHandler() {\n          private final Platform platform = Platform.get();\n\n          @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)\n              throws Throwable {\n            // If the method is a method from Object then defer to normal invocation.\n            if (method.getDeclaringClass() == Object.class) {\n              return method.invoke(this, args);\n            }\n            if (platform.isDefaultMethod(method)) {\n              return platform.invokeDefaultMethod(method, service, proxy, args);\n            }\n            ServiceMethod<Object, Object> serviceMethod =\n                (ServiceMethod<Object, Object>) loadServiceMethod(method);\n            OkHttpCall<Object> okHttpCall = new OkHttpCall<>(serviceMethod, args);\n            return serviceMethod.adapt(okHttpCall);\n          }\n        });\n}\n```\n进入create方法可以看到return部分的代码实际是一个动态代理，因此create返回的GitHubService实例实际是一个代理类的实例，在调用其listRepos\b方法的时候实际\b会去执行create中的invoke方法。因此所有操作都是在invoke方法中完成的。其中最关键的两部分代码就是\n``` Java \nServiceMethod<Object, Object> serviceMethod =\n(ServiceMethod<Object, Object>) loadServiceMethod(method);\nOkHttpCall<Object> okHttpCall = new OkHttpCall<>(serviceMethod, args);\n```\nmethod实际就是自定义接口GitHubService中的listRepos方法。\b下面看看loadServiceMethod方法做了哪些工作。在loadServiceMethod中首先查看缓存中是否已经有对应的ServiceMethod，如果没有\b则创建，并缓存起来。主要就是看创建ServiceMethod所做的工作,ServiceMethod也是通过Builder模式创建,进入build()方法中进行查看：\n``` Java\npublic ServiceMethod build() {\n      callAdapter = createCallAdapter();\n      responseType = callAdapter.responseType();\n      if (responseType == Response.class || responseType == okhttp3.Response.class) {\n        throw methodError(\"'\"\n            + Utils.getRawType(responseType).getName()\n            + \"' is not a valid response body type. Did you mean ResponseBody?\");\n      }\n      responseConverter = createResponseConverter();\n\n      for (Annotation annotation : methodAnnotations) {\n        parseMethodAnnotation(annotation);\n      }\n\n      if (httpMethod == null) {\n        throw methodError(\"HTTP method annotation is required (e.g., @GET, @POST, etc.).\");\n      }\n\n      if (!hasBody) {\n        if (isMultipart) {\n          throw methodError(\n              \"Multipart can only be specified on HTTP methods with request body (e.g., @POST).\");\n        }\n        if (isFormEncoded) {\n          throw methodError(\"FormUrlEncoded can only be specified on HTTP methods with \"\n              + \"request body (e.g., @POST).\");\n        }\n      }\n\n      int parameterCount = parameterAnnotationsArray.length;\n      parameterHandlers = new ParameterHandler<?>[parameterCount];\n      for (int p = 0; p < parameterCount; p++) {\n        Type parameterType = parameterTypes[p];\n        if (Utils.hasUnresolvableType(parameterType)) {\n          throw parameterError(p, \"Parameter type must not include a type variable or wildcard: %s\",\n              parameterType);\n        }\n\n        Annotation[] parameterAnnotations = parameterAnnotationsArray[p];\n        if (parameterAnnotations == null) {\n          throw parameterError(p, \"No Retrofit annotation found.\");\n        }\n\n        parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);\n      }\n\n      if (relativeUrl == null && !gotUrl) {\n        throw methodError(\"Missing either @%s URL or @Url parameter.\", httpMethod);\n      }\n      if (!isFormEncoded && !isMultipart && !hasBody && gotBody) {\n        throw methodError(\"Non-body HTTP method cannot contain @Body.\");\n      }\n      if (isFormEncoded && !gotField) {\n        throw methodError(\"Form-encoded method must contain at least one @Field.\");\n      }\n      if (isMultipart && !gotPart) {\n        throw methodError(\"Multipart method must contain at least one @Part.\");\n      }\n\n      return new ServiceMethod<>(this);\n}\n```\n\n首先调用的是createCallAdapter方法：\n``` Java\nprivate CallAdapter<T, R> createCallAdapter() {\n      Type returnType = method.getGenericReturnType();\n      if (Utils.hasUnresolvableType(returnType)) {\n        throw methodError(\n            \"Method return type must not include a type variable or wildcard: %s\", returnType);\n      }\n      if (returnType == void.class) {\n        throw methodError(\"Service methods cannot return void.\");\n      }\n      Annotation[] annotations = method.getAnnotations();\n      try {\n        //noinspection unchecked\n        return (CallAdapter<T, R>) retrofit.callAdapter(returnType, annotations);\n      } catch (RuntimeException e) { // Wide exception range because factories are user code.\n        throw methodError(e, \"Unable to create call adapter for %s\", returnType);\n      }\n}\n```\ncreateCallAdapter方法中首先获取接口方法返回类型，比如说之前定义的GitHubService接口中listRepos方法的返回值类型`Call<List<Repo>>`,泛型返回值不能有通配符或者类型参数符号例如T。最后调用Retrofit中callAdapter方法，跟踪\b进去实际到最后是调用的ExecutorCallAdapterFactory中的get方法，返回一个匿名内部类CallAdapter。\b返回\b到loadServiceMethod方法中responseType即为List<Repo>。接下来就是创建responseConverter，responseConverter作用就是将响应转换为我们需要的类型。\b调用createResponseConverter方法创建，调用流程为：ServiceMethod.createResponseConverter()->Retrofit.responseBodyConverter()->Retrofit.nextResponseBodyConverter();最后在nextResponseBodyConverter方法中通过converterFactories进行获取，而converterFactories\b是一个List，存放的元素就是Converter.Factory，在之前的示例中我使用的是GsonConverterFactory.create()，这个是Gson的转换器，通过addConverterFactory方法添加。  \n\n回到create方法，\b在invoke方法中最后调用serviceMethod.adapt();进入adapt方法发现实际调用的是callAdapter的adapt方法。callAdapter前面分析过就是ExecutorCallAdapterFactory中get方法返回的\b匿名内部类CallAdapter对象。调用其adapt方法最后返回的对象是ExecutorCallbackCall，调用其enqueue方法实际调用的是Call对象的enqueue方法，即OkHttpCall对象的enqueue方法。在enqueue方法中调用的\bcall.enqueue()方法。call对象通过ServiceMethod.toCall()方法创建，toCall方法内部通过callFactory.newCall()创建，之前分析callFactory实际就是OkHttpClient，后面的处理由OKkHttpClient完成。这时整个Retrofit从创建请求到发送整个流程分析完了，可见最后请求发送是通过OkHttpClient实现的，也就是说实际发送网络请求的是OkHttp。Retrofit只是完成了创建请求以及通过Converter处理响应。大致执行流程如下图所示：\n![avatar](/img/Retrofit.png)\n","tags":["Android"]},{"title":"RxJava 学习及源码分析","url":"/2018/08/11/RxJava-学习及源码分析/","tags":["Android"]},{"title":"动态代理","url":"/2018/07/25/Dynamic-Proxy/","content":"# 动态代理\n","tags":["Java"]},{"title":"Hello World","url":"/2018/07/24/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]