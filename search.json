[{"title":"OkHttp3 源码分析","url":"/2018/09/02/OkHttp3-源码分析/","content":"> Okhttp是当下Android端最为流行的网络请求库，其优点也很明显，使用方便，高效。\n\n## OkHttp简单使用\nokhttp的使用极其简单，以创建异步请求为例：\n``` Java\nOkHttpClient httpClient = new OkHttpClient();\n\nRequest.Builder builder = new Request.Builder().get().url(\"http://www.baidu.com\");\nRequest request = builder.build();\n\nhttpClient.newCall(request).enqueue(new Callback() {\n    @Override\n    public void onFailure(@NonNull Call call, @NonNull IOException e) {\n\n    }\n\n    @Override\n    public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {\n        Log.e(\"future\",response.body().string());\n    }\n});\n```\n可以看到okHttp发送请求确实很简单，因为OkHttp在背后做了很多工作。现在去探探究竟。\n## OkHttp源码解析\nOkHttpClient类与Request类均是使用的Builder模式。创建好的Request是如何发送出去的病如何接收响应的呢？从以上示例可以看到通过OkHttpClient的newCall方法创建一个Call对象，然后调用其enqueue方法。进入newCall方法\n``` Java\n@Override public Call newCall(Request request) {\n    return RealCall.newRealCall(this, request, false /* for web socket */);\n}\n```\n实际是通过RealCall.newRealCall方法创建的Call对象。在newRealCall方法中：\n``` Java\nstatic RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {\n    // Safely publish the Call instance to the EventListener.\n    RealCall call = new RealCall(client, originalRequest, forWebSocket);\n    call.eventListener = client.eventListenerFactory().create(call);\n    return call;\n}\n```\n由以上可知创建的是一个RealCall对象，因此查看RealCall的enqueue方法：\n``` Java\n@Override public void enqueue(Callback responseCallback) {\n    synchronized (this) {\n      if (executed) throw new IllegalStateException(\"Already Executed\");\n      executed = true;\n    }\n    captureCallStackTrace();\n    eventListener.callStart(this);\n    client.dispatcher().enqueue(new AsyncCall(responseCallback));\n}\n```\nclient.dispatcher().enqueue调用的是调度器Dispatcher的enqueue方法。在Dispatcher的enqueue方法中：\n``` Java\nsynchronized void enqueue(AsyncCall call) {\n    if (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {\n      runningAsyncCalls.add(call);\n      executorService().execute(call);\n    } else {\n      readyAsyncCalls.add(call);\n    }\n}\n```\nDiapatcher有三个队列：\n``` Java\n/** Ready async calls in the order they'll be run. */\nprivate final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();\n\n/** Running asynchronous calls. Includes canceled calls that haven't finished yet. */\nprivate final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();\n\n/** Running synchronous calls. Includes canceled calls that haven't finished yet. */\nprivate final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();\n```\n前面两个与异步调用有关，runningSyncCalls用于同步调用。异步调用时，如果正在运行中的请求数量小于maxRequests（默认为64）并且当前call的host的请求数量小于maxRequestsPerHost（默认为5）时，则加入runningAsyncCalls队列并执行，否则加入readyAsyncCalls。将AsyncCall加入线程池中执行，AsyncCall是一个Runnable对象，因此会执行其run方法，其run方法在父类NameRunnable中实现，在run方法中实际调用执行的是execute方法。因此整体的一个流程就是newCall->newRealCall->enqueue(RealCall)->enqueue(Dispatcher)->ExecutorService(execute)->AsyncCall(execute);\n进入AsyncCall的execute方法：\n``` Java\n@Override protected void execute() {\n    boolean signalledCallback = false;\n    try {\n    Response response = getResponseWithInterceptorChain();\n    if (retryAndFollowUpInterceptor.isCanceled()) {\n        signalledCallback = true;\n        responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n    } else {\n        signalledCallback = true;\n        responseCallback.onResponse(RealCall.this, response);\n    }\n    } catch (IOException e) {\n    if (signalledCallback) {\n        // Do not signal the callback twice!\n        Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n    } else {\n        eventListener.callFailed(RealCall.this, e);\n        responseCallback.onFailure(RealCall.this, e);\n    }\n    } finally {\n    client.dispatcher().finished(this);\n    }\n}\n```\nexecute方法中比较关键的就是`Response response = getResponseWithInterceptorChain();`进入getResponseWithInterceptorChain方法，从名字可以看出将进入拦截器链。\n\n### 拦截器\n\n``` Java\nResponse getResponseWithInterceptorChain() throws IOException {\n    // Build a full stack of interceptors.\n    List<Interceptor> interceptors = new ArrayList<>();\n    interceptors.addAll(client.interceptors());\n    interceptors.add(retryAndFollowUpInterceptor);\n    interceptors.add(new BridgeInterceptor(client.cookieJar()));\n    interceptors.add(new CacheInterceptor(client.internalCache()));\n    interceptors.add(new ConnectInterceptor(client));\n    if (!forWebSocket) {\n      interceptors.addAll(client.networkInterceptors());\n    }\n    interceptors.add(new CallServerInterceptor(forWebSocket));\n\n    Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,\n        originalRequest, this, eventListener, client.connectTimeoutMillis(),\n        client.readTimeoutMillis(), client.writeTimeoutMillis());\n\n    return chain.proceed(originalRequest);\n}\n```\n在`getResponseWithInterceptorChain`方法中，创建了一系列拦截器并添加到ArrayList中。其中client.interceptors()是由我们自己自定义的拦截器，通过OkHttpClient的addInterceptor方法添加。自定义拦截器用途后面再讲，这个是一个很强大，很灵活的功能。\n代码创建了一个RealInterceptorChain实例后调用其proceed方法。下面一步步分析拦截器链是如何工作的。\n\n进入RealInterCeptChain的proceed方法：\n``` Java\npublic Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,\n      RealConnection connection) throws IOException {\n    if (index >= interceptors.size()) throw new AssertionError();\n\n    calls++;\n\n    // If we already have a stream, confirm that the incoming request will use it.\n    if (this.httpCodec != null && !this.connection.supportsUrl(request.url())) {\n      throw new IllegalStateException(\"network interceptor \" + interceptors.get(index - 1)\n          + \" must retain the same host and port\");\n    }\n\n    // If we already have a stream, confirm that this is the only call to chain.proceed().\n    if (this.httpCodec != null && calls > 1) {\n      throw new IllegalStateException(\"network interceptor \" + interceptors.get(index - 1)\n          + \" must call proceed() exactly once\");\n    }\n\n    // Call the next interceptor in the chain.\n    RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,\n        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,\n        writeTimeout);\n    Interceptor interceptor = interceptors.get(index);\n    Response response = interceptor.intercept(next);\n\n    // Confirm that the next interceptor made its required call to chain.proceed().\n    if (httpCodec != null && index + 1 < interceptors.size() && next.calls != 1) {\n      throw new IllegalStateException(\"network interceptor \" + interceptor\n          + \" must call proceed() exactly once\");\n    }\n\n    // Confirm that the intercepted response isn't null.\n    if (response == null) {\n      throw new NullPointerException(\"interceptor \" + interceptor + \" returned null\");\n    }\n\n    if (response.body() == null) {\n      throw new IllegalStateException(\n          \"interceptor \" + interceptor + \" returned a response with no body\");\n    }\n\n    return response;\n}\n```\n关键在于这三句代码：\n``` Java\nRealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,writeTimeout);\nInterceptor interceptor = interceptors.get(index);\nResponse response = interceptor.intercept(next);\n```\n在这里又创建了一个RealInterceptorChain实例，与当前RealInterceptorChain实例不同的是次此对象的index加了1，然后从拦截器列表中获取第一个（也就是index为0的拦截器），如果没有自定义拦截器，此时获取的就是RetryAndFollowUpInterceptor拦截器。调用其intercept方法并将创建的RealInterceptorChain传过去。在intercept方法中先不去看其他逻辑。intercept方法中首先创建StreamAllocation对象，然后有调用RealInterceptorChain的proceed方法，进入下一个拦截器的调用，根据之前的拦截器列表可知是BridgeInterceptor。在BridgeInterceptor中进行了一系列请求头部的解析之后调用RealInterceptorChain的proceed方法，进入下一个拦截器CacheInterceptor：\n\n``` Java\n@Override public Response intercept(Chain chain) throws IOException {\n    Response cacheCandidate = cache != null\n        ? cache.get(chain.request())\n        : null;\n\n    long now = System.currentTimeMillis();\n\n    CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();\n    Request networkRequest = strategy.networkRequest;\n    Response cacheResponse = strategy.cacheResponse;\n\n    if (cache != null) {\n      cache.trackResponse(strategy);\n    }\n\n    if (cacheCandidate != null && cacheResponse == null) {\n      closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.\n    }\n\n    // If we're forbidden from using the network and the cache is insufficient, fail.\n    if (networkRequest == null && cacheResponse == null) {\n      return new Response.Builder()\n          .request(chain.request())\n          .protocol(Protocol.HTTP_1_1)\n          .code(504)\n          .message(\"Unsatisfiable Request (only-if-cached)\")\n          .body(Util.EMPTY_RESPONSE)\n          .sentRequestAtMillis(-1L)\n          .receivedResponseAtMillis(System.currentTimeMillis())\n          .build();\n    }\n\n    // If we don't need the network, we're done.\n    if (networkRequest == null) {\n      return cacheResponse.newBuilder()\n          .cacheResponse(stripBody(cacheResponse))\n          .build();\n    }\n\n    Response networkResponse = null;\n    try {\n      networkResponse = chain.proceed(networkRequest);\n    } finally {\n      // If we're crashing on I/O or otherwise, don't leak the cache body.\n      if (networkResponse == null && cacheCandidate != null) {\n        closeQuietly(cacheCandidate.body());\n      }\n    }\n\n    // If we have a cache response too, then we're doing a conditional get.\n    if (cacheResponse != null) {\n      if (networkResponse.code() == HTTP_NOT_MODIFIED) {\n        Response response = cacheResponse.newBuilder()\n            .headers(combine(cacheResponse.headers(), networkResponse.headers()))\n            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())\n            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())\n            .cacheResponse(stripBody(cacheResponse))\n            .networkResponse(stripBody(networkResponse))\n            .build();\n        networkResponse.body().close();\n\n        // Update the cache after combining headers but before stripping the\n        // Content-Encoding header (as performed by initContentStream()).\n        cache.trackConditionalCacheHit();\n        cache.update(cacheResponse, response);\n        return response;\n      } else {\n        closeQuietly(cacheResponse.body());\n      }\n    }\n\n    Response response = networkResponse.newBuilder()\n        .cacheResponse(stripBody(cacheResponse))\n        .networkResponse(stripBody(networkResponse))\n        .build();\n\n    if (cache != null) {\n      if (HttpHeaders.hasBody(response) && CacheStrategy.isCacheable(response, networkRequest)) {\n        // Offer this request to the cache.\n        CacheRequest cacheRequest = cache.put(response);\n        return cacheWritingResponse(cacheRequest, response);\n      }\n\n      if (HttpMethod.invalidatesCache(networkRequest.method())) {\n        try {\n          cache.remove(networkRequest);\n        } catch (IOException ignored) {\n          // The cache cannot be written.\n        }\n      }\n    }\n\n    return response;\n}\n```\n`CacheInterceptor`的作用就是判断是否发送请求获取响应还是直接使用缓存返回,并更新缓存。通过 `CacheStrategy.Factory(now, chain.request(), cacheCandidate).get()`获取缓策略。在这个方法中，主要通过判断networkRequest以及cacheResponse进行响应的返回。如果networkRequest以及cacheResponse都为空则返回504；如果networkRequest为空，但是cacheResponse不为空，那么将cacheResponse返回。networkRequest和cacheResponse到底是什么呢？根据代码前面一部分networkRequest和cacheResponse是通过CacheStrategy获取的。调用CacheStrategy的工厂方法，调用工厂方法时传入了 chain.request(), cacheCandidate，如果\ncache为空的话那么cacheCandidate就为空\n``` Java\npublic Factory(long nowMillis, Request request, Response cacheResponse) {\n    this.nowMillis = nowMillis;\n    this.request = request;\n    this.cacheResponse = cacheResponse;\n\n    if (cacheResponse != null) {\n        this.sentRequestMillis = cacheResponse.sentRequestAtMillis();\n        this.receivedResponseMillis = cacheResponse.receivedResponseAtMillis();\n        Headers headers = cacheResponse.headers();\n        for (int i = 0, size = headers.size(); i < size; i++) {\n          String fieldName = headers.name(i);\n          String value = headers.value(i);\n          if (\"Date\".equalsIgnoreCase(fieldName)) {\n            servedDate = HttpDate.parse(value);\n            servedDateString = value;\n          } else if (\"Expires\".equalsIgnoreCase(fieldName)) {\n            expires = HttpDate.parse(value);\n          } else if (\"Last-Modified\".equalsIgnoreCase(fieldName)) {\n            lastModified = HttpDate.parse(value);\n            lastModifiedString = value;\n          } else if (\"ETag\".equalsIgnoreCase(fieldName)) {\n            etag = value;\n          } else if (\"Age\".equalsIgnoreCase(fieldName)) {\n            ageSeconds = HttpHeaders.parseSeconds(value, -1);\n          }\n        }\n    }\n}\n```\n如果cacheResponse即响应缓存不为空的话，就对响应头部进行解析。cacheResponse由cache是否为空决定，然后进入CacheStrategy的get方法中进行查看，将get方法与内部调用的getCandidate方法结合起来分析：\n``` Java\npublic CacheStrategy get() {\n      CacheStrategy candidate = getCandidate();\n\n      if (candidate.networkRequest != null && request.cacheControl().onlyIfCached()) {\n        // We're forbidden from using the network and the cache is insufficient.\n        return new CacheStrategy(null, null);\n      }\n\n      return candidate;\n}\n```\n``` Java\nprivate CacheStrategy getCandidate() {\n      // No cached response.\n      if (cacheResponse == null) {\n        return new CacheStrategy(request, null);\n      }\n\n      // Drop the cached response if it's missing a required handshake.\n      if (request.isHttps() && cacheResponse.handshake() == null) {\n        return new CacheStrategy(request, null);\n      }\n\n      // If this response shouldn't have been stored, it should never be used\n      // as a response source. This check should be redundant as long as the\n      // persistence store is well-behaved and the rules are constant.\n      if (!isCacheable(cacheResponse, request)) {\n        return new CacheStrategy(request, null);\n      }\n\n      CacheControl requestCaching = request.cacheControl();\n      if (requestCaching.noCache() || hasConditions(request)) {\n        return new CacheStrategy(request, null);\n      }\n\n      CacheControl responseCaching = cacheResponse.cacheControl();\n      if (responseCaching.immutable()) {\n        return new CacheStrategy(null, cacheResponse);\n      }\n\n      long ageMillis = cacheResponseAge();\n      long freshMillis = computeFreshnessLifetime();\n\n      if (requestCaching.maxAgeSeconds() != -1) {\n        freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));\n      }\n\n      long minFreshMillis = 0;\n      if (requestCaching.minFreshSeconds() != -1) {\n        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());\n      }\n\n      long maxStaleMillis = 0;\n      if (!responseCaching.mustRevalidate() && requestCaching.maxStaleSeconds() != -1) {\n        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());\n      }\n\n      if (!responseCaching.noCache() && ageMillis + minFreshMillis < freshMillis + maxStaleMillis) {\n        Response.Builder builder = cacheResponse.newBuilder();\n        if (ageMillis + minFreshMillis >= freshMillis) {\n          builder.addHeader(\"Warning\", \"110 HttpURLConnection \\\"Response is stale\\\"\");\n        }\n        long oneDayMillis = 24 * 60 * 60 * 1000L;\n        if (ageMillis > oneDayMillis && isFreshnessLifetimeHeuristic()) {\n          builder.addHeader(\"Warning\", \"113 HttpURLConnection \\\"Heuristic expiration\\\"\");\n        }\n        return new CacheStrategy(null, builder.build());\n      }\n\n      // Find a condition to add to the request. If the condition is satisfied, the response body\n      // will not be transmitted.\n      String conditionName;\n      String conditionValue;\n      if (etag != null) {\n        conditionName = \"If-None-Match\";\n        conditionValue = etag;\n      } else if (lastModified != null) {\n        conditionName = \"If-Modified-Since\";\n        conditionValue = lastModifiedString;\n      } else if (servedDate != null) {\n        conditionName = \"If-Modified-Since\";\n        conditionValue = servedDateString;\n      } else {\n        return new CacheStrategy(request, null); // No condition! Make a regular request.\n      }\n\n      Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();\n      Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);\n\n      Request conditionalRequest = request.newBuilder()\n          .headers(conditionalRequestHeaders.build())\n          .build();\n      return new CacheStrategy(conditionalRequest, cacheResponse);\n}\n```\n此方法中的逻辑：\n* 如果cacheResponse为空，那么构造CacheStragtegy的时候传入的cacheResponse就为空，networkRequest就是传进来的request\n* 如果请求是https并且TLS握手为空的话，则构造CacheStrategy时候CacheResponse为空\n* 通过request的CacheControl进行判断`requestCaching.noCache() || hasConditions(request)`,如果请求头部包含“no-cache”那么noCache()方法返回true。如果请求头部包含If-Modified-Since或者If-None-Match，则也返回true，此时构造CacheStrategy时传入的cacheResponse为空\n* 如果cacheResponse的CacheControl包含immutable，那么此时CacheStrategy的networkRequest为空\n* 如果没有设置noCache并且依然在设置的有效期内，此时CacheStrategy的networkRequest为空，cacheResponse为缓存的响应\n* 如果缓存的cacheResponse没有If-None-Match或者If-Modified-Since或者If-Modified-Since，则构造CacheStrategy时传入的cacheResponse为空。否则构造CacheStrategy时传入构造的conditionalRequest以及cacheResponse   \n\n返回到get方法中如果请求头包含only-if-cached，此时构造的CacheStrategy中networkRequest以及cacheResponse都为空。\n\n终上所述，通过以上各种情况可以得出在哪些情况直接使用缓存，什么时候返回504，什么时候需要发送请求，在CacheIntercept中主要就是做的这些事情。\n\n接下来就是ConnectInterceptor，连接拦截器，intercept方法中代码不多，但是这里做了很多工作，创建连接，连接复用等逻辑：\n\n``` Java\n@Override public Response intercept(Chain chain) throws IOException {\n    RealInterceptorChain realChain = (RealInterceptorChain) chain;\n    Request request = realChain.request();\n    StreamAllocation streamAllocation = realChain.streamAllocation();\n\n    // We need the network to satisfy this request. Possibly for validating a conditional GET.\n    boolean doExtensiveHealthChecks = !request.method().equals(\"GET\");\n    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);\n    RealConnection connection = streamAllocation.connection();\n\n    return realChain.proceed(request, streamAllocation, httpCodec, connection);\n}\n```\n最关键部分就是streamAllocation.newStream(client, chain, doExtensiveHealthChecks)。通过调用newStream->findHealthyConnection->findConnection,直接进入findConnection进行查看：\n``` Java\nprivate RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,\n      int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException {\n    boolean foundPooledConnection = false;\n    RealConnection result = null;\n    Route selectedRoute = null;\n    Connection releasedConnection;\n    Socket toClose;\n    synchronized (connectionPool) {\n      if (released) throw new IllegalStateException(\"released\");\n      if (codec != null) throw new IllegalStateException(\"codec != null\");\n      if (canceled) throw new IOException(\"Canceled\");\n\n      // Attempt to use an already-allocated connection. We need to be careful here because our\n      // already-allocated connection may have been restricted from creating new streams.\n      releasedConnection = this.connection;\n      toClose = releaseIfNoNewStreams();\n      if (this.connection != null) {\n        // We had an already-allocated connection and it's good.\n        result = this.connection;\n        releasedConnection = null;\n      }\n      if (!reportedAcquired) {\n        // If the connection was never reported acquired, don't report it as released!\n        releasedConnection = null;\n      }\n\n      if (result == null) {\n        // Attempt to get a connection from the pool.\n        Internal.instance.get(connectionPool, address, this, null);\n        if (connection != null) {\n          foundPooledConnection = true;\n          result = connection;\n        } else {\n          selectedRoute = route;\n        }\n      }\n    }\n    closeQuietly(toClose);\n\n    if (releasedConnection != null) {\n      eventListener.connectionReleased(call, releasedConnection);\n    }\n    if (foundPooledConnection) {\n      eventListener.connectionAcquired(call, result);\n    }\n    if (result != null) {\n      // If we found an already-allocated or pooled connection, we're done.\n      return result;\n    }\n\n    // If we need a route selection, make one. This is a blocking operation.\n    boolean newRouteSelection = false;\n    if (selectedRoute == null && (routeSelection == null || !routeSelection.hasNext())) {\n      newRouteSelection = true;\n      routeSelection = routeSelector.next();\n    }\n\n    synchronized (connectionPool) {\n      if (canceled) throw new IOException(\"Canceled\");\n\n      if (newRouteSelection) {\n        // Now that we have a set of IP addresses, make another attempt at getting a connection from\n        // the pool. This could match due to connection coalescing.\n        List<Route> routes = routeSelection.getAll();\n        for (int i = 0, size = routes.size(); i < size; i++) {\n          Route route = routes.get(i);\n          Internal.instance.get(connectionPool, address, this, route);\n          if (connection != null) {\n            foundPooledConnection = true;\n            result = connection;\n            this.route = route;\n            break;\n          }\n        }\n      }\n\n      if (!foundPooledConnection) {\n        if (selectedRoute == null) {\n          selectedRoute = routeSelection.next();\n        }\n\n        // Create a connection and assign it to this allocation immediately. This makes it possible\n        // for an asynchronous cancel() to interrupt the handshake we're about to do.\n        route = selectedRoute;\n        refusedStreamCount = 0;\n        result = new RealConnection(connectionPool, selectedRoute);\n        acquire(result, false);\n      }\n    }\n\n    // If we found a pooled connection on the 2nd time around, we're done.\n    if (foundPooledConnection) {\n      eventListener.connectionAcquired(call, result);\n      return result;\n    }\n\n    // Do TCP + TLS handshakes. This is a blocking operation.\n    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,\n        connectionRetryEnabled, call, eventListener);\n    routeDatabase().connected(result.route());\n\n    Socket socket = null;\n    synchronized (connectionPool) {\n      reportedAcquired = true;\n\n      // Pool the connection.\n      Internal.instance.put(connectionPool, result);\n\n      // If another multiplexed connection to the same address was created concurrently, then\n      // release this connection and acquire that one.\n      if (result.isMultiplexed()) {\n        socket = Internal.instance.deduplicate(connectionPool, address, this);\n        result = connection;\n      }\n    }\n    closeQuietly(socket);\n\n    eventListener.connectionAcquired(call, result);\n    return result;\n}\n```\n方法名称为findConnection，因为连接不一定是直接创建，有可能是复用连接池中的连接。connectionPool是在OkHttpClient的builder中进行初始化的，`connectionPool = new ConnectionPool()`;首先进入同步代码块中，首先判断该StreamAllocation分配的资源是否已经释放，接着判断流是否已经结束，或者StreamAllocation是否取消。"},{"title":"Java内存模型(《深入理解Java虚拟机》学习笔记)","url":"/2018/08/25/Java内存模型/","content":"## \n\n## volatile变量特殊规则\n`volatile`变量的语义：一个共享变量如果加了volatile修饰以后具备两层语义：\n* 保证此变量对所有线程的可见性，当一条线程修改了这个变量的值，新值对所有其他线程是立即可知的\n* 第二个就是禁止指令的重排序优化，对于非volatile变量只会保证执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证赋值的顺序与程序代码中顺序一致。","tags":["JVM"]},{"title":"Java垃圾回收机制","url":"/2018/08/25/Java垃圾回收机制/"},{"title":"线程池ThreadPoolExecutor","url":"/2018/08/25/线程池ThreadPoolExecutor/"},{"title":"显式锁ReentrantLock","url":"/2018/08/25/显式锁ReentrantLock/","content":"Java5.0之前，协调共享对象访问的机制只有s`ynchronized`和`volatile`。Java5.0增加了一种新的机制：`ReentrantLock`。ReentrantLock并不是替代内置锁，而是当内置锁机制不适用的时候，作为一种可选择的高级功能。","tags":["并发"]},{"title":"CountDownLatch学习","url":"/2018/08/25/CountDownLatch学习/"},{"title":"RecyclerView源码解析","url":"/2018/08/13/RecyclerView源码解析/","tags":["Android"]},{"title":"ArrayList与LinkedList","url":"/2018/08/12/ArrayList与LinkedList/","content":"ArrayList与LinkedList都是可变容量容器，\b均实现了List接口，但是ArrayList与LinkedList实现原理却有很大区别，实现方式决定了其使用场景\n\n## ArrayList源码分析\nArrayList有三个构造函数，一个无参构造，一个带有Collection参数，一个带有int型参数。ArrayList内部是基于数组实现的。默认的容量为10。对于一个容器来说，最频繁的操作莫过于添加，和删除了。首先看看添加操作。add方法有几个重载函数，首先看最基本的只有一个\b泛型类型参数的add方法。\n### Add方法\n``` Java\npublic boolean add(E e) {\n    modCount++;\n    add(e, elementData, size);\n    return true;\n}\n\nprivate void add(E e, Object[] elementData, int s) {\n    if (s == elementData.length)\n        elementData = grow();\n    elementData[s] = e;\n    size = s + 1;\n}\n\nprivate Object[] grow() {\n    return grow(size + 1);\n}\n\nprivate Object[] grow(int minCapacity) {\n    return elementData = Arrays.copyOf(elementData,\n            newCapacity(minCapacity));\n}\n\n```\n调用`add(E e)`执行流程：add(E e)->add(E e, Object[] elementData, int s) （如果数组数据装满了）->grow()->grow(int minCapacity);可以看到如果数据没有装满则其实就是简单的在内部数组中添加元素，并增加size大小。但是数组一旦确定大小是不能改变的，而ArrayList要动态改变大小，\b关键就在grow方法中，ArrayList通过grow方法“改变数组容量”。实际是将原来的数据复制到一个新的容量大的数组中去，那么新数组容量大小如何确定呢？就看newCapacity方法：\n``` Java\nprivate int newCapacity(int minCapacity) {\n    // overflow-conscious code\n    int oldCapacity = elementData.length;\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    if (newCapacity - minCapacity <= 0) {\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)\n            return Math.max(DEFAULT_CAPACITY, minCapacity);\n        if (minCapacity < 0) // overflow\n            throw new OutOfMemoryError();\n        return minCapacity;\n    }\n    return (newCapacity - MAX_ARRAY_SIZE <= 0)\n        ? newCapacity\n        : hugeCapacity(minCapacity);\n}\n```\n新的容量为oldCapacity+oldCapacity/2倍。如果newCapacity-minCapacity<=0（minCapacity即为size+1，因为此时size与elementData.length相等，因此minCapacity为oldCapacity+1），此时elementData为默认的空数组的时候(如果使用无参构造函数就会出现这种情况)，此时返回容量为默认容量DEFAULT_CAPACITY与minCapacity之间的大者，否则返回minCapacity。如果\bnewCapacity-minCapacity<=0不满足则返回newCapacity，此时会处理一下如果容量超过最大数组大小时的情况。回到grow方法中：\n``` Java\nprivate Object[] grow(int minCapacity) {\n    return elementData = Arrays.copyOf(elementData,\n            newCapacity(minCapacity));\n}\n```\n使用的是Arrays.copyOf将原数组复制到新的数组中。跟踪进去最后可以看到是调用的：\n``` Java\npublic static <T,U> T[] copyOf(U[] original, int newLength, Class<? extends T[]> newType) {\n    @SuppressWarnings(\"unchecked\")\n    T[] copy = ((Object)newType == (Object)Object[].class)\n        ? (T[]) new Object[newLength]\n        : (T[]) Array.newInstance(newType.getComponentType(), newLength);\n    System.arraycopy(original, 0, copy, 0,\n                        Math.min(original.length, newLength));\n    return copy;\n}\n```\n在copyOf方法中首先创建了一个泛型数组，然后调用System.arraycopy方法将原数组数据复制到泛型数组中。其他的add方法以及addAll方法都是同样的思路，先判断数组容量是否够，如果不够则需要调用grow方法扩容，扩容实际就是创建一个指定容量的新数组，然后将原数组数据复制到新数组中。\n\n### 删除元素remove方法\nremove也有几个重载方法\n``` Java\npublic E remove(int index) {\n    Objects.checkIndex(index, size);\n\n    modCount++;\n    E oldValue = elementData(index);\n\n    int numMoved = size - index - 1;\n    if (numMoved > 0)\n        System.arraycopy(elementData, index+1, elementData, index,\n                            numMoved);\n    elementData[--size] = null; // clear to let GC do its work\n\n    return oldValue;\n}\n```\n从代码可以看出remove操作实际也是进行了System.arraycopy操作的，当然前提是不是remove末端的数据。最后有个很重要的`elementData[--size] = null`操作，置空的原因是为了能够垃圾回收，防止内存泄漏。这个System.arraycopy方法是何方神圣？进去看看就知道：\n``` Java\npublic static native void arraycopy(Object src,  int  srcPos,\n        Object dest, int destPos,int length);\n```\n这是一个native函数，包含五个参数分别是源数组，需要复制的起始位置， 目标数组， 目标数组放置数据的起始位置，需要复制的数据长度。需要注意的是arraycopy方法是一个浅拷贝。源数组中的元素与新数组重的元素指向的是同一个对象，因此改变其中一个会影响另一个。\n\n### 获取元素get()方法\nget()方法就比较容易，因为是顺序存储get(int)方法直接通过数组索引去获取元素，查找很高效，复杂度为O(1),获取之前检查索引是否越界。\n\n### 其他方法\n其他的方法如indexOf，lastIndexOf查找均是通过循环遍历进行的查找,平均复杂度为O(n);\nArrayList中有个很重要的地方就是fail-fast behavior,叫做快速失败行为。ArrayList中有一个成员变量叫做modCount，add操作和remove都会使modCount增加1，在通过listIterator()方法获取ListIterator之后,如果使用了非ListIterator里面的remove操作或者add方法的话，然后再使用listIterator的操作就会产生ConcurrentModificationException异常。\n例如：\n``` Java\npublic class Demo {\n    public static void main(String[] args) {\n        ArrayList<String> strings = new ArrayList<>();\n        strings.add(\"hello\");\n        ListIterator<String> iterator= strings.listIterator();\n        strings.add(\"world\");//或者使用strings.remove();\n        iterator.add(\"future\");\n    }\n}\n```\n不管是iterator.add()方法还是iterator.next()或者previos()方法都会产生ConcurrentModificationException。为什么会出现这个问题呢？在查看ListIterator的源代码可以看到，next(), previous(), add(),方法都有执行一个checkForComodification方法，进入checkForComodification方法：\n``` Java \nfinal void checkForComodification() {\n    if (modCount != expectedModCount)\n        throw new ConcurrentModificationException();\n}\n```\n这个方法里面比较了modCount 和 expectedModCount，expectedModCount在创建Iterator的时候通过modCount赋值。调用ArrayList的add方法或者Remove方法时都会modCount++，会改变modCount的值，因此就导致if为真，产生ConcurrentModificationException。  \n\b除了使用Iterator之外，使用forEach循环也会出现同样的问题，原因是对于集合使用forEach，其原理还是\b使用的Iterator实现的：\n``` Java\nfor (type var : coll) {\n    body-of-loop\n}\n\nfor (Iterator<type> iter = coll.iterator(); iter.hasNext(); ) {\n    type var = iter.next();\n    body-of-loop\n}\n```\n上面是等价的两者是等价的。  \n最后需要说明的是ArrayList是非线程安全的。\n\n## LinkedList源码分析\nLinkedList采用的是双链表的实现的,实现了List和Deque接口。同理我们首先还是看最常用的插入，删除操作。\n``` Java\npublic boolean add(E e) {\n    linkLast(e);\n    return true;\n}\n```\nadd(E e)将一个元素加入list末尾。在内部调用linkLast方法。\n``` Java\nvoid linkLast(E e) {\n    final Node<E> l = last;\n    final Node<E> newNode = new Node<>(l, e, null);\n    last = newNode;\n    if (l == null)\n        first = newNode;\n    else\n        l.next = newNode;\n    size++;\n    modCount++;\n}\n```\n","tags":["Collections"]},{"title":"Algorithms 4th 学习笔记","url":"/2018/08/12/Algorithms-4th-学习笔记/","tags":["DSA"]},{"title":"Java集合学习及源码分析","url":"/2018/08/12/Java集合学习/","tags":["Collections"]},{"title":"Java运行时数据区域","url":"/2018/08/12/Java运行时数据区域/","tags":["JVM"]},{"title":"Java虚拟机学习","url":"/2018/08/12/Java虚拟机学习/","content":"不管是在写学习客户端还是Java后端，越来越觉得学习Java虚拟机的必要性，以下内容是我在学习《深入理解Java虚拟机》的学习笔记，作为对JVM一个入门的了解。\n* [运行时数据区域](https://futurerui.github.io/2018/08/12/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/)\n* [JVM垃圾回收机制]()\n* [类文件结构]()\n* [Java类加载机制]()\n* [Java内存模型]()","tags":["JVM"]},{"title":"Java并发编程学习","url":"/2018/08/12/Java并发编程/","content":"并发编程是Java学习过程中需要重点掌握的东西，平时做Android客户端的开发接触到的并发并不是很多，而且通常都是一些比较简单的东西。而正是因为如此，就更需要去学习并发的内容。在Android中使用Okhttp进行异步请求时，内部实际就使用了线程池。因此学好基础很重要。本系列文章包括学习《Java并发编程实战》的笔记以及自己在学习过程中的一些学习心得。","tags":["并发"]},{"title":"Retrofit学习及源码分析","url":"/2018/08/11/Retrofit学习及源码分析/","content":"最近参加的很多面试都有问到Retrofit以及RxJava，奈何以前项目使用得不多，因此很遗憾错过了一些比较想去的公司，痛定思痛，因此回家后好好研究了一番。但是实际上做开发，要不断地学习给自己充电，否则就会掉队，因此学习不仅仅是为了应付面试，也不是说项目使用了才去学习，这是不断充实自己的一个过程。\n\n## Retrofit 简介\nRetrofit在[官网](http://square.github.io/retrofit/)有一句简单的介绍：A type-safe HTTP client for Android and Java。翻译过来就是用于Java和Android的类型安全的http客户端。\n\n## Retrofit 使用\n在grdle文件中添加依赖  \n\n``` gradle \n    implementation 'com.squareup.retrofit2:retrofit:2.4.0' \n```\n查看引进的依赖可以看到添加Retrofit依赖后自动依赖了Okhttp。\n### 定义接口\n``` Java\npublic interface GitHubService {\n    @GET(\"users/{user}/repos\")\n    Call<List<Repo>> listRepos(@Path(\"user\") String user);\n}\n```\n通过注解定义描述Http请求，Retrofit内置了五个注解GET，POST，PUT，DELETE，HEAD，如果使用HTTP注解的话可以替换以上任意一个注解。Retrofit将网络请求地址分成两部分，一个是baseURL，剩下的在接口方法中通过注解进行设置。接口中的方法返回一个Call实例。   \n请求URL可以通过替换块以及方法的参数进行动态的替换，如上述示例中通过使用{}可以实现在方法`listRepos`中动态替换，方法参数需要添加竹节`@Path(\"user\")`.  \n通过`@Query`注解可以实现动态替换URL中的参数，如下所示：\n\n``` Java \n@GET(\"users/list?sort=desc\")//写在注解中\n\n@GET(\"group/{id}/users\")\nCall<List<User>> groupList(@Path(\"id\") int groupId, @Query(\"sort\") String sort);//通过参数动态添加\n\n```\n如果有多个参数可以通过map实现，例如：\n  \n``` Java\n@GET(\"group/{id}/users\")\nCall<List<User>> groupList(@Path(\"id\") int groupId, @QueryMap Map<String, String> options);\n```\n### 调用接口\n接口定义好之后通过Retrofit设置baseURL并将请求发送出去：  \n\n``` Java \nRetrofit retrofit = new Retrofit.Builder()\n                        .addConverterFactory(GsonConverterFactory.create())\n                        .baseUrl(\"https://api.github.com/\").build();\nGitHubService service = retrofit.create(GitHubService.class);\nservice.listRepos(\"futurerui\").enqueue(new Callback<List<Repo>>() {\n    @Override\n    public void onResponse(Call<List<Repo>> call, Response<List<Repo>> response) {\n        Log.e(\"future\",\"\");\n    }\n\n    @Override\n    public void onFailure(Call<List<Repo>> call, Throwable t) {\n        Log.e(\"future\",\"\");\n    }\n});\n```\n类`Repo`是服务器返回数据的类,类中只定义了其中一部分数据：\n``` Java\npublic class Repo {\n    private String id;\n    private String name;\n    private String full_name;\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getFull_name() {\n        return full_name;\n    }\n\n    public void setFull_name(String full_name) {\n        this.full_name = full_name;\n    }\n}\n```\n通过调用create方法返回`GitHubService`实例，调用接口方法`listRepos`返回Call对象，\b调用enqueue方法将请求发送出去。  \n\b以上的示例是以GET方式请求，对于POST请求则需要使用@POST注解\n### 注解说明\n#### RequestBody\n通过`@Body`注解可以将对象设置为请求体\n``` Java\n@POST(\"users/new\")\nCall<User> createUser(@Body User user);\n```\nUser会通过Converter进行转换，如果没有设置Converter则只能使用RequestBody。\n\n#### Form Encoded以及Multipart\n当使用`@FormUrlEncoded`注解的时候会发送表单编码的数据,使用此注解表示MineType为`application/x-www-form-urlencoded`。即：\n```\nContent-Type:application/x-www-form-urlencoded\n```\n此时键值对通过`@Field`注解进行标注\n``` Java\n@FormUrlEncoded\n@POST(\"user/edit\")\nCall<User> updateUser(@Field(\"first_name\") String first, @Field(\"last_name\") String last);\n```\n`@Part` 和`PartMap`与注解`Multipart`结合使用，适用于文件上传。`Query`以及`QueryMap`用于URL上，而`Part`与`PartMap`用于请求体上。MultiPart表示请求体是一个支持文件上传的表单：\n```\nContent-Type:multipart/form-data\n```\n\n#### 请求头\n设置请求头的方式：\n* 通过@Headers注解在接口方法添加静态请求头\n* 通过@Header注解在接口方法参数中动态添加请求头\n如下所示：\n``` Java\n@Headers({\n    \"Accept: application/vnd.github.v3.full+json\",\n    \"User-Agent: Retrofit-Sample-App\"\n})\n@GET(\"users/{username}\")\nCall<User> getUser(@Path(\"username\") String username);\n```\n动态方式：\n``` Java\n@GET(\"user\")\nCall<User> getUser(@Header(\"Authorization\") String authorization)\n```\n类似于query参数，对于复杂的请求头可以使用Map方式进行动态添加，如下所示：\n``` Java \n@GET(\"user\")\nCall<User> getUser(@HeaderMap Map<String, String> headers)\n```\n如果每个请求中都需要添加相同的Header，这时可以通过OkHttp的拦截器实现。  \n\n## Retrofit源码分析\n简单的介绍了Retrofit的使用，那么Retrofit内部是如何实现的呢？Retrofit整个内部源码很少，但是构思却如此精妙，下面一起看看内部是如何实现的。  \nRetrofit实例是通过builder模式创建，然后通过baseUrl方法设置url基础部分。baseUrl与在接口方法中设置的路径的关系：\n* 如果在接口方法中设置的路径以`/`开头，那么表示此路径是绝对路径，此时会把baseUrl中\b包含的其他路径参数给覆盖掉：\n``` \nbaseUrl = \"http://example.com/api/\"\nendPoint = \"/foo/bar/\"\nresult = \"http://example.com/foo/bar/\"\n```\n* 如果EndPoint中包含host或者包含\b协议部分，则会替换掉baseUrl中的host，如果没有包含协议部分则使用baseUrl中的协议， 如果包含协议则会覆盖baseUrl的协议。\n```\nBase URL: http://example.com/\nEndpoint: https://github.com/square/retrofit/\nResult: https://github.com/square/retrofit/\n\nBase URL: http://example.com\nEndpoint: //github.com/square/retrofit/\nResult: http://github.com/square/retrofit/ \n```\n调用build()方法完成Retrofit实例的创建\n``` Java\npublic Retrofit build() {\n      if (baseUrl == null) {\n        throw new IllegalStateException(\"Base URL required.\");\n      }\n\n      okhttp3.Call.Factory callFactory = this.callFactory;\n      if (callFactory == null) {\n        callFactory = new OkHttpClient();\n      }\n\n      Executor callbackExecutor = this.callbackExecutor;\n      if (callbackExecutor == null) {\n        callbackExecutor = platform.defaultCallbackExecutor();\n      }\n\n      // Make a defensive copy of the adapters and add the default Call adapter.\n      List<CallAdapter.Factory> callAdapterFactories = new ArrayList<>(this.callAdapterFactories);\n      callAdapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));\n\n      // Make a defensive copy of the converters.\n      List<Converter.Factory> converterFactories =\n          new ArrayList<>(1 + this.converterFactories.size());\n\n      // Add the built-in converter factory first. This prevents overriding its behavior but also\n      // ensures correct behavior when using converters that consume all types.\n      converterFactories.add(new BuiltInConverters());\n      converterFactories.addAll(this.converterFactories);\n\n      return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),\n          unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);\n}\n```\n在build方法中完成了`callFactory`的实例化，`call\bFactory`默认是采用`OkHttpClient`进行实例化的。接下来是实例化`callbackExecutor`，这个\b默认是通过platform的`defaultCallbackExecutor`方法实例化。platform又是个什么东东。找到platform初始化的地方可以看到platform是通过`Platform.get();`初始化的。\n``` Java\nprivate static Platform findPlatform() {\n    try {\n      Class.forName(\"android.os.Build\");\n      if (Build.VERSION.SDK_INT != 0) {\n        return new Android();\n      }\n    } catch (ClassNotFoundException ignored) {\n    }\n    try {\n      Class.forName(\"java.util.Optional\");\n      return new Java8();\n    } catch (ClassNotFoundException ignored) {\n    }\n    return new Platform();\n}\n```\nplatform是通过反射进行确定运行在哪个平台然后进行相应的初始化，我是在Android上面使用，因此是Android类的实例。进入Android\b类中：\n``` Java\nstatic class Android extends Platform {\n    @Override public Executor defaultCallbackExecutor() {\n      return new MainThreadExecutor();\n    }\n\n    @Override CallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) {\n      if (callbackExecutor == null) throw new AssertionError();\n      return new ExecutorCallAdapterFactory(callbackExecutor);\n    }\n\n    static class MainThreadExecutor implements Executor {\n      private final Handler handler = new Handler(Looper.getMainLooper());\n\n      @Override public void execute(Runnable r) {\n        handler.post(r);\n      }\n    }\n}\n```\ncallbackExecutor是MainThreadExecutor实例。MainThreadExecutor中有一个使用主线程Looper的Handler实例。调用execute方法的时候是通过handler将runnable post出去的。  \n\n接下来就是callAdapterFactories实例，callAdapterFactories是一个List通过Retrofit的构造函数传递给Retrofit的成员变量callAdapterFactories。callAdapterFactories\b默认通过paltform的defaultCallAdapterFactory方法添加元素。\n``` Java\nCallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) {\n    if (callbackExecutor != null) {\n      return new ExecutorCallAdapterFactory(callbackExecutor);\n    }\n    return DefaultCallAdapterFactory.INSTANCE;\n}\n```\n因为callbackExecutor不为null，因此返回ExecutorCallAdapterFactory的实例。获取到Retrofit实例以后调用create方法获取定义的接口GitHubService的\b实例。create方法可以说是Retrofit最核心的部分。\n``` Java\npublic <T> T create(final Class<T> service) {\n    Utils.validateServiceInterface(service);\n    if (validateEagerly) {\n      eagerlyValidateMethods(service);\n    }\n    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },\n        new InvocationHandler() {\n          private final Platform platform = Platform.get();\n\n          @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)\n              throws Throwable {\n            // If the method is a method from Object then defer to normal invocation.\n            if (method.getDeclaringClass() == Object.class) {\n              return method.invoke(this, args);\n            }\n            if (platform.isDefaultMethod(method)) {\n              return platform.invokeDefaultMethod(method, service, proxy, args);\n            }\n            ServiceMethod<Object, Object> serviceMethod =\n                (ServiceMethod<Object, Object>) loadServiceMethod(method);\n            OkHttpCall<Object> okHttpCall = new OkHttpCall<>(serviceMethod, args);\n            return serviceMethod.adapt(okHttpCall);\n          }\n        });\n}\n```\n进入create方法可以看到return部分的代码实际是一个动态代理，因此create返回的GitHubService实例实际是一个代理类的实例，在调用其listRepos\b方法的时候实际\b会去执行create中的invoke方法。因此所有操作都是在invoke方法中完成的。其中最关键的两部分代码就是\n``` Java \nServiceMethod<Object, Object> serviceMethod =\n(ServiceMethod<Object, Object>) loadServiceMethod(method);\nOkHttpCall<Object> okHttpCall = new OkHttpCall<>(serviceMethod, args);\n```\nmethod实际就是自定义接口GitHubService中的listRepos方法。\b下面看看loadServiceMethod方法做了哪些工作。在loadServiceMethod中首先查看缓存中是否已经有对应的ServiceMethod，如果没有\b则创建，并缓存起来。主要就是看创建ServiceMethod所做的工作,ServiceMethod也是通过Builder模式创建,进入build()方法中进行查看：\n``` Java\npublic ServiceMethod build() {\n      callAdapter = createCallAdapter();\n      responseType = callAdapter.responseType();\n      if (responseType == Response.class || responseType == okhttp3.Response.class) {\n        throw methodError(\"'\"\n            + Utils.getRawType(responseType).getName()\n            + \"' is not a valid response body type. Did you mean ResponseBody?\");\n      }\n      responseConverter = createResponseConverter();\n\n      for (Annotation annotation : methodAnnotations) {\n        parseMethodAnnotation(annotation);\n      }\n\n      if (httpMethod == null) {\n        throw methodError(\"HTTP method annotation is required (e.g., @GET, @POST, etc.).\");\n      }\n\n      if (!hasBody) {\n        if (isMultipart) {\n          throw methodError(\n              \"Multipart can only be specified on HTTP methods with request body (e.g., @POST).\");\n        }\n        if (isFormEncoded) {\n          throw methodError(\"FormUrlEncoded can only be specified on HTTP methods with \"\n              + \"request body (e.g., @POST).\");\n        }\n      }\n\n      int parameterCount = parameterAnnotationsArray.length;\n      parameterHandlers = new ParameterHandler<?>[parameterCount];\n      for (int p = 0; p < parameterCount; p++) {\n        Type parameterType = parameterTypes[p];\n        if (Utils.hasUnresolvableType(parameterType)) {\n          throw parameterError(p, \"Parameter type must not include a type variable or wildcard: %s\",\n              parameterType);\n        }\n\n        Annotation[] parameterAnnotations = parameterAnnotationsArray[p];\n        if (parameterAnnotations == null) {\n          throw parameterError(p, \"No Retrofit annotation found.\");\n        }\n\n        parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);\n      }\n\n      if (relativeUrl == null && !gotUrl) {\n        throw methodError(\"Missing either @%s URL or @Url parameter.\", httpMethod);\n      }\n      if (!isFormEncoded && !isMultipart && !hasBody && gotBody) {\n        throw methodError(\"Non-body HTTP method cannot contain @Body.\");\n      }\n      if (isFormEncoded && !gotField) {\n        throw methodError(\"Form-encoded method must contain at least one @Field.\");\n      }\n      if (isMultipart && !gotPart) {\n        throw methodError(\"Multipart method must contain at least one @Part.\");\n      }\n\n      return new ServiceMethod<>(this);\n}\n```\n\n首先调用的是createCallAdapter方法：\n``` Java\nprivate CallAdapter<T, R> createCallAdapter() {\n      Type returnType = method.getGenericReturnType();\n      if (Utils.hasUnresolvableType(returnType)) {\n        throw methodError(\n            \"Method return type must not include a type variable or wildcard: %s\", returnType);\n      }\n      if (returnType == void.class) {\n        throw methodError(\"Service methods cannot return void.\");\n      }\n      Annotation[] annotations = method.getAnnotations();\n      try {\n        //noinspection unchecked\n        return (CallAdapter<T, R>) retrofit.callAdapter(returnType, annotations);\n      } catch (RuntimeException e) { // Wide exception range because factories are user code.\n        throw methodError(e, \"Unable to create call adapter for %s\", returnType);\n      }\n}\n```\ncreateCallAdapter方法中首先获取接口方法返回类型，比如说之前定义的GitHubService接口中listRepos方法的返回值类型`Call<List<Repo>>`,泛型返回值不能有通配符或者类型参数符号例如T。最后调用Retrofit中callAdapter方法，跟踪\b进去实际到最后是调用的ExecutorCallAdapterFactory中的get方法，返回一个匿名内部类CallAdapter。\b返回\b到loadServiceMethod方法中responseType即为List<Repo>。接下来就是创建responseConverter，responseConverter作用就是将响应转换为我们需要的类型。\b调用createResponseConverter方法创建，调用流程为：ServiceMethod.createResponseConverter()->Retrofit.responseBodyConverter()->Retrofit.nextResponseBodyConverter();最后在nextResponseBodyConverter方法中通过converterFactories进行获取，而converterFactories\b是一个List，存放的元素就是Converter.Factory，在之前的示例中我使用的是GsonConverterFactory.create()，这个是Gson的转换器，通过addConverterFactory方法添加。  \n\n回到create方法，\b在invoke方法中最后调用serviceMethod.adapt();进入adapt方法发现实际调用的是callAdapter的adapt方法。callAdapter前面分析过就是ExecutorCallAdapterFactory中get方法返回的\b匿名内部类CallAdapter对象。调用其adapt方法最后返回的对象是ExecutorCallbackCall，调用其enqueue方法实际调用的是Call对象的enqueue方法，即OkHttpCall对象的enqueue方法。在enqueue方法中调用的\bcall.enqueue()方法。call对象通过ServiceMethod.toCall()方法创建，toCall方法内部通过callFactory.newCall()创建，之前分析callFactory实际就是OkHttpClient，后面的处理由OKkHttpClient完成。这时整个Retrofit从创建请求到发送整个流程分析完了，可见最后请求发送是通过OkHttpClient实现的，也就是说实际发送网络请求的是OkHttp。Retrofit只是完成了创建请求以及通过Converter处理响应。大致执行流程如下图所示：\n![avatar](/img/Retrofit.png)\n","tags":["Android"]},{"title":"RxJava 学习及源码分析","url":"/2018/08/11/RxJava-学习及源码分析/","tags":["Android"]},{"title":"动态代理","url":"/2018/07/25/Dynamic-Proxy/","content":"# 动态代理\n","tags":["Java"]},{"title":"Hello World","url":"/2018/07/24/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]